// Teensy 4.1 — SiPM Fast-Out ADC windowed counter + LED + CSV (Serial + SD)
// Columns: time_ms,voltage_V,hit,cum_counts
// - LED (pin 13) blinks while measuring, solid ON when finished
// - Measurement: 10 s default, 10 kS/s default (SAMPLE_US = 100)
// - Counts only on rising entry into 0.060..0.300 V window (with hysteresis + refractory)

#include <Arduino.h>
#include <SD.h>
#include <SPI.h>

// -------------------- User Config --------------------
const int   LED_PIN        = 13;      // onboard LED
const int   ADC_PIN        = A0;      // <-- connect SiPM fast-out here (0–3.3 V ONLY!)

const uint32_t DURATION_MS = 10000;   // total measurement time (10 s)
const uint32_t SAMPLE_US   = 100;     // sample period (100 µs = 10 kS/s)
const uint32_t BLINK_MS    = 200;     // LED blink while measuring
const uint32_t FLUSH_EVERY = 100;     // flush SD every N lines

// ADC settings
const int   ADC_BITS       = 12;      // 0..4095
const int   ADC_AVG_HW     = 1;       // fastest (no HW averaging)
const float ADC_VREF       = 3.3f;    // Teensy ADC reference (keep input <= 3.3 V)

// Windowed detection (volts). Counts on rising entry into this window.
const float LOWER_ENTER_V  = 0.30f;  // 60 mV: must rise past this to consider a hit
const float LOWER_EXIT_V   = 0.300f;  // 50 mV: must fall below this to re-arm (hysteresis)
const float UPPER_LIMIT_V  = 0.800f;  // 300 mV: must be <= this at hit moment

// Refractory (ignore re-triggers for this long after a hit), µs
const uint32_t REFRACT_US  = 300;     // tune to your pulse width

// -------------------- Globals --------------------
File logfile;
bool ledState = false;
uint32_t lastBlink = 0;

inline void blinkWhileRunning() {
  uint32_t now = millis();
  if (now - lastBlink >= BLINK_MS) {

    ledState = !ledState;
    digitalWrite(LED_PIN, ledState);
    lastBlink = now;
  }
}

String nextCsvFilename() {
  for (int i = 0; i < 1000; ++i) {
    char name[24];
    snprintf(name, sizeof(name), "counts%03d.csv", i);
    if (!SD.exists(name)) return String(name);
  }
  return String("counts.csv");
}

// -------------------- Setup --------------------
void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  // Start Serial immediately (do not wait)
  Serial.begin(115200);

  // SD init (onboard slot)
  if (!SD.begin(BUILTIN_SDCARD)) {
    // Fast blink forever = SD init failure
    while (1) { digitalWrite(LED_PIN, !digitalRead(LED_PIN)); delay(100); }
  }

  // Create CSV log
  String fname = nextCsvFilename();
  logfile = SD.open(fname.c_str(), FILE_WRITE);
  if (!logfile) {
    // Medium blink forever = file open failure
    while (1) { digitalWrite(LED_PIN, !digitalRead(LED_PIN)); delay(200); }
  }

  // Headers
  Serial.println("time_ms,voltage_V,hit,cum_counts");
  logfile.println("time_ms,voltage_V,hit,cum_counts");

  // ADC config
  analogReadResolution(ADC_BITS);
  analogReadAveraging(ADC_AVG_HW);
  (void)analogRead(ADC_PIN);  // warm-up dummy read

  // Timing anchors
  const uint32_t t0_ms = millis();
  const uint32_t t0_us = micros();
  uint32_t next_sample_us = t0_us;
  lastBlink = t0_ms;

  // Detection state
  const float countsPerVolt = ADC_VREF / ((1UL << ADC_BITS) - 1UL);
  bool     armed        = true;     // waiting for rising entry into window
  uint32_t last_hit_us  = 0;        // last counted hit time
  uint32_t cum_counts   = 0;
  uint32_t lines_since_flush = 0;

  // -------------------- Measurement Loop --------------------
  while ((millis() - t0_ms) < DURATION_MS) {
    blinkWhileRunning();

    uint32_t now_us = micros();
    if ((int32_t)(now_us - next_sample_us) < 0) continue;
    next_sample_us += SAMPLE_US;

    // ADC -> V
    int   raw = analogRead(ADC_PIN);
    float v   = raw * countsPerVolt;

    // Windowed detection with hysteresis + refractory
    uint8_t hit = 0;
    if (armed) {
      if (v >= LOWER_ENTER_V && v <= UPPER_LIMIT_V && (now_us - last_hit_us) >= REFRACT_US) {
        hit = 1;
        ++cum_counts;
        last_hit_us = now_us;
        armed = false;  // disarm until we drop below LOWER_EXIT_V
      }
    } else {
      if (v < LOWER_EXIT_V) {
        armed = true;   // re-arm after falling low
      }
    }

    // Timestamp (ms since start)
    float t_ms = (now_us - t0_us) / 1000.0f;

    // Output CSV to Serial
    Serial.print(t_ms, 3); Serial.print(',');
    Serial.print(v, 4);    Serial.print(',');
    Serial.print(hit);     Serial.print(',');
    Serial.println(cum_counts);

    // Output CSV to SD
    logfile.print(t_ms, 3); logfile.print(',');
    logfile.print(v, 4);    logfile.print(',');
    logfile.print(hit);     logfile.print(',');
    logfile.println(cum_counts);

    if (++lines_since_flush >= FLUSH_EVERY) {
      logfile.flush();
      lines_since_flush = 0;
    }
  }

  // Finish
  logfile.flush();
  logfile.close();
  digitalWrite(LED_PIN, HIGH);  // solid ON when done
}

// -------------------- Loop --------------------
void loop() {
  // Idle (LED solid ON)
  delay(1000);
}
